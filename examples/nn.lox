class NeuralNetwork {
  init() {
    // Define network structure
    this.inputSize = 2;
    this.hiddenSize = 2;
    this.outputSize = 1;

    // Initialize weights for input to hidden layer
    this.weightsInputHidden = Array(this.hiddenSize);
    for (var i = 0; i < this.hiddenSize; i = i + 1) {
      var hiddenWeights = Array(this.inputSize);
      for (var j = 0; j < this.inputSize; j = j + 1) {
        if (j == 0) {
          hiddenWeights.set(j, 0.05 + (i * 0.02));
        } else {
          hiddenWeights.set(j, -0.05 + (i * 0.02));
        }
      }
      this.weightsInputHidden.set(i, hiddenWeights);
    }

    // Initialize weights for hidden to output layer
    this.weightsHiddenOutput = Array(this.outputSize);
    for (var i = 0; i < this.outputSize; i = i + 1) {
      var outputWeights = Array(this.hiddenSize);
      for (var j = 0; j < this.hiddenSize; j = j + 1) {
        if (j == 0) {
          outputWeights.set(j, 0.07 + (i * 0.02));
        } else {
          outputWeights.set(j, -0.07 + (i * 0.02));
        }
      }
      this.weightsHiddenOutput.set(i, outputWeights);
    }

    // Initialize biases
    this.biasHidden = Array(this.hiddenSize);
    for (var i = 0; i < this.hiddenSize; i = i + 1) {
      this.biasHidden.set(i, 0.0);
    }

    this.biasOutput = Array(this.outputSize);
    for (var i = 0; i < this.outputSize; i = i + 1) {
      this.biasOutput.set(i, 0.0);
    }

    this.learningRate = 0.5;
  }

  // Activation function
  sigmoid(x) {
    if (x < -2) { return 0; }
    if (x < 0) { return (x + 2) / 2; }
    if (x < 2) { return (2 - x) / 2; }
    return 0;
  }

  // Derivative of activation function
  sigmoidDerivative(x) {
    if (x < -2 or x > 2) { return 0; }
    if (x < 0) { return 0.5; }
    if (x < 2) { return -0.5; }
    return 0;
  }

  // Forward pass
  forward(xInputs) {
    this.inputs = xInputs;

    // Hidden layer
    this.hiddenInputs = Array(this.hiddenSize);
    this.hiddenOutputs = Array(this.hiddenSize);
    for (var i = 0; i < this.hiddenSize; i = i + 1) {
      var sum = 0;
      for (var j = 0; j < this.inputSize; j = j + 1) {
        sum = sum + this.weightsInputHidden.get(i).get(j) * this.inputs.get(j);
      }
      sum = sum + this.biasHidden.get(i);
      this.hiddenInputs.set(i, sum);
      this.hiddenOutputs.set(i, this.sigmoid(sum));
    }

    // Output layer
    this.outputInputs = Array(this.outputSize);
    this.outputs = Array(this.outputSize);
    for (var i = 0; i < this.outputSize; i = i + 1) {
      var sum = 0;
      for (var j = 0; j < this.hiddenSize; j = j + 1) {
        sum = sum + this.weightsHiddenOutput.get(i).get(j) * this.hiddenOutputs.get(j);
      }
      sum = sum + this.biasOutput.get(i);
      this.outputInputs.set(i, sum);
      this.outputs.set(i, this.sigmoid(sum));
    }

    return this.outputs.get(0);
  }

  // Training with backpropagation
  train(xInputs, target) {
    var prediction = this.forward(xInputs);
    var error = target - prediction;

    // Output layer delta
    var deltaOutput = Array(this.outputSize);
    for (var i = 0; i < this.outputSize; i = i + 1) {
      deltaOutput.set(i, error * this.sigmoidDerivative(this.outputInputs.get(i)));
    }

    // Hidden layer deltas
    var deltaHidden = Array(this.hiddenSize);
    for (var i = 0; i < this.hiddenSize; i = i + 1) {
      var sum = 0;
      for (var j = 0; j < this.outputSize; j = j + 1) {
        sum = sum + deltaOutput.get(j) * this.weightsHiddenOutput.get(j).get(i);
      }
      sum = sum * this.sigmoidDerivative(this.hiddenInputs.get(i));
      deltaHidden.set(i, sum);
    }

    // Update weights hidden to output
    for (var i = 0; i < this.outputSize; i = i + 1) {
      for (var j = 0; j < this.hiddenSize; j = j + 1) {
        var currentWeight = this.weightsHiddenOutput.get(i).get(j);
        var delta = this.learningRate * deltaOutput.get(i) * this.hiddenOutputs.get(j);
        this.weightsHiddenOutput.get(i).set(j, currentWeight + delta);
      }
    }

    // Update biases output
    for (var i = 0; i < this.outputSize; i = i + 1) {
      var currentBias = this.biasOutput.get(i);
      var delta = this.learningRate * deltaOutput.get(i);
      this.biasOutput.set(i, currentBias + delta);
    }

    // Update weights input to hidden
    for (var i = 0; i < this.hiddenSize; i = i + 1) {
      for (var j = 0; j < this.inputSize; j = j + 1) {
        var currentWeight = this.weightsInputHidden.get(i).get(j);
        var delta = this.learningRate * deltaHidden.get(i) * this.inputs.get(j);
        this.weightsInputHidden.get(i).set(j, currentWeight + delta);
      }
    }

    // Update biases hidden
    for (var i = 0; i < this.hiddenSize; i = i + 1) {
      var currentBias = this.biasHidden.get(i);
      var delta = this.learningRate * deltaHidden.get(i);
      this.biasHidden.set(i, currentBias + delta);
    }

    return error * error;
  }

  // Train on all training samples (XOR problem)
  trainEpoch() {
    var totalError = 0;

    var input00 = Array(this.inputSize);
    input00.set(0, 0);
    input00.set(1, 0);
    totalError = totalError + this.train(input00, 0);

    var input01 = Array(this.inputSize);
    input01.set(0, 0);
    input01.set(1, 1);
    totalError = totalError + this.train(input01, 1);

    var input10 = Array(this.inputSize);
    input10.set(0, 1);
    input10.set(1, 0);
    totalError = totalError + this.train(input10, 1);

    var input11 = Array(this.inputSize);
    input11.set(0, 1);
    input11.set(1, 1);
    totalError = totalError + this.train(input11, 0);

    return totalError;
  }
}

// Create network
var nn = NeuralNetwork();

// Training parameters
var epoch = 0;
var nextPrint = 0;
var maxEpochs = 10000;
var errorThreshold = 0.01;

// Training loop
while (epoch < maxEpochs) {
  var error = nn.trainEpoch();

  if (epoch == nextPrint) {
    print "Epoch " + epoch + " Error: " + error;
    print "Weights and Biases:";

    // Print weights input to hidden
    for (var i = 0; i < nn.hiddenSize; i = i + 1) {
      var weights = "";
      for (var j = 0; j < nn.inputSize; j = j + 1) {
        weights = weights + "w" + (i * nn.inputSize + j + 1) + ": " + nn.weightsInputHidden.get(i).get(j) + ", ";
      }
      print "Hidden neuron " + (i + 1) + " weights: " + weights + "b" + (i + 1) + ": " + nn.biasHidden.get(i);
    }

    // Print weights hidden to output
    for (var i = 0; i < nn.outputSize; i = i + 1) {
      var weights = "";
      for (var j = 0; j < nn.hiddenSize; j = j + 1) {
        weights = weights + "w" + (nn.hiddenSize * nn.inputSize + j + 1) + ": " + nn.weightsHiddenOutput.get(i).get(j) + ", ";
      }
      print "Output neuron " + (i + 1) + " weights: " + weights + "b" + (nn.hiddenSize + i + 1) + ": " + nn.biasOutput.get(i);
    }

    nextPrint = nextPrint + 500;
  }

  epoch = epoch + 1;
}

print "Final results:";

// Final results
var finalInput00 = Array(2);
finalInput00.set(0, 0);
finalInput00.set(1, 0);
print "0 XOR 0 = " + nn.forward(finalInput00);

var finalInput01 = Array(2);
finalInput01.set(0, 0);
finalInput01.set(1, 1);
print "0 XOR 1 = " + nn.forward(finalInput01);

var finalInput10 = Array(2);
finalInput10.set(0, 1);
finalInput10.set(1, 0);
print "1 XOR 0 = " + nn.forward(finalInput10);

var finalInput11 = Array(2);
finalInput11.set(0, 1);
finalInput11.set(1, 1);
print "1 XOR 1 = " + nn.forward(finalInput11);
